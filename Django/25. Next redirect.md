#### The `login_required` decorator[¶](https://docs.djangoproject.com/en/5.2/topics/auth/default/#the-login-required-decorator "Link to this heading")

`login_required(redirect_field_name='next', login_url=None)`

As a shortcut, you can use the convenient [`login_required()`](https://docs.djangoproject.com/en/5.2/topics/auth/default/#django.contrib.auth.decorators.login_required "django.contrib.auth.decorators.login_required") decorator:
```Python
from django.contrib.auth.decorators import login_required

@login_required
def my_view(request): ...
```

[`login_required()`](https://docs.djangoproject.com/en/5.2/topics/auth/default/#django.contrib.auth.decorators.login_required "django.contrib.auth.decorators.login_required") does the following:
- If the user isn’t logged in, redirect to [`settings.LOGIN_URL`](https://docs.djangoproject.com/en/5.2/ref/settings/#std-setting-LOGIN_URL), passing the current absolute path in the query string. Example: `/accounts/login/?next=/polls/3/`.
    
- If the user is logged in, execute the view normally. The view code is free to assume the user is logged in.
By default, the path that the user should be redirected to upon successful authentication is stored in a query string parameter called `"next"`. If you would prefer to use a different name for this parameter, [`login_required()`](https://docs.djangoproject.com/en/5.2/topics/auth/default/#django.contrib.auth.decorators.login_required "django.contrib.auth.decorators.login_required") takes an optional `redirect_field_name` parameter:

```Python
from django.contrib.auth.decorators import login_required

@login_required(redirect_field_name="my_redirect_field")
def my_view(request): ...

```
Note that if you provide a value to `redirect_field_name`, you will most likely need to customize your login template as well, since the template context variable which stores the redirect path will use the value of `redirect_field_name` as its key rather than `"next"` (the default).

[`login_required()`](https://docs.djangoproject.com/en/5.2/topics/auth/default/#django.contrib.auth.decorators.login_required "django.contrib.auth.decorators.login_required") also takes an optional `login_url` parameter. Example:
```Python
from django.contrib.auth.decorators import login_required

@login_required(login_url="/accounts/login/")
def my_view(request): ...
```

Note that if you don’t specify the `login_url` parameter, you’ll need to ensure that the [`settings.LOGIN_URL`](https://docs.djangoproject.com/en/5.2/ref/settings/#std-setting-LOGIN_URL) and your login view are properly associated. For example, using the defaults, add the following lines to your URLconf:
```Python
from django.contrib.auth import views as auth_views

path("accounts/login/", auth_views.LoginView.as_view()),
```

The [`settings.LOGIN_URL`](https://docs.djangoproject.com/en/5.2/ref/settings/#std-setting-LOGIN_URL) also accepts view function names and [named URL patterns](https://docs.djangoproject.com/en/5.2/topics/http/urls/#naming-url-patterns). This allows you to freely remap your login view within your URLconf without having to update the setting.

# Get 'next' then redirect
When you want to do something that need login and it has `login_required` decorator it has a `next` in URL:
```Python
from django.shortcuts import render, redirect
from . import forms as cfs
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.models import User
from django.contrib.auth.decorators import login_required

  
def login_page(request):
    next = request.GET.get('next') # Important
    if request.user.is_authenticated:
        return redirect('accounts:dashboard_page_name')
    login_form = cfs.UserLoginForm()
    if request.method == 'POST':
        login_form = cfs.UserLoginForm(data=request.POST)
        if login_form.is_valid():
            username_input = login_form.cleaned_data.get('username')
            password_input = login_form.cleaned_data.get('password')
            user = authenticate(request, username=username_input, password=password_input)

            if user is not None:
                login(request, user)
                if next: # Important
                    return redirect(next)
                else:
                    return redirect('accounts:dashboard_page_name')
            else:
                login_form.add_error('password', 'Invalid username or password!')
    context = {
        'login_form': login_form
    }
    return render(request, 'accounts/login_index.html', context)
```

# Passing **query strings** from links in Django-HTML
```Django
{% if request.user.is_authenticated %}
<h3>Write your comment</h3>
	<form action="{% url 'blog:article_detail_name' article.id%}" method="post" enctype="multipart/form-data">
		{% csrf_token %}
		{{form.as_p}}
		{% if form.errors %}
			<br>
			<h4>Form Errors</h4>
			{{form.errors}}
			{% comment %} 
			{% for field in form %}
				{% if field.errors %}
					<ul>
						<li>
							{{ field.label_tag }}
							<br>
							<ul>
								{% for error in field.errors %}
									<li>
									{{ error }}
									</li>
								{% endfor %}
							</ul>
							<!-- Display errors for each field -->
						</li>
					</ul>
				{% endif %}
			{% endfor %} 
			{% endcomment %}
		{% endif %}
		<button type="submit">Submit</button>
	</form>

{% else %} {% comment %} Important {% endcomment %}
	<p><a href="{% url 'accounts:login_page_name' %}?next={% url 'blog:article_detail_name' article.id %}">Login</a> to leave a comment.</p>
{% endif %}
```
You can see how the `next` injected to the URL.
```Django
<a href="{% url 'accounts:login_page_name' %}?next={% url 'blog:article_detail_name' article.id %}">Login</a>
```