admin.py in blog app:
> [!NOTE] Filename: `admin.py`
```Python
from django.contrib import admin

# Register your models here.
from . import models


# @admin.register(models.Article)
class ArticleAdmin(admin.ModelAdmin):
    list_display = ['title', 'author', 'created_date', 'update_date', 'is_show']
    search_fields = ['title', 'text']
    list_editable = ['is_show']
    list_filter = ['is_show', 'author']
    date_hierarchy = 'created_date'
    ordering = ['-title', 'text'] # Order by title descending, then by text ascending | You can order by id and other fields
    fieldsets = [
        (
            None,
            {
                'fields': ['title', 'text', 'image', 'is_show'],
            },
        ),
        (
            'Advanced options',
            {
                'classes': ['collapse'],
                'fields': ['author'],
            },
        ),
    ]
  
admin.site.register(models.Article, ArticleAdmin)
# admin.site.register(models.Comment)

@admin.register(models.Comment)
class CommentAdmin(admin.ModelAdmin):
    readonly_fields = ['user_object', 'article_object', 'image']
```

# ModelAdmin.raw_id_fields[¶](https://docs.djangoproject.com/en/5.2/ref/contrib/admin/#django.contrib.admin.ModelAdmin.raw_id_fields "Link to this definition")

By default, Django’s admin uses a select-box interface select for fields that are `ForeignKey`. Sometimes you don’t want to incur the overhead of having to select all the related instances to display in the drop-down.

`raw_id_fields` is a list of fields you would like to change into an `Input` widget for either a `ForeignKey` or `ManyToManyField`:
```Python
class ArticleAdmin(admin.ModelAdmin):
    raw_id_fields = ['author']
```
The `raw_id_fields` `Input` widget should contain a primary key if the field is a `ForeignKey` or a comma separated list of values if the field is a `ManyToManyField`. The `raw_id_fields` widget shows a magnifying glass button next to the field which allows users to search for and select a value.

# ModelAdmin.prepopulated_fields[¶](https://docs.djangoproject.com/en/5.2/ref/contrib/admin/#django.contrib.admin.ModelAdmin.prepopulated_fields "Link to this definition")

Set `prepopulated_fields` to a dictionary mapping field names to the fields it should prepopulate from:
```Python
class ArticleAdmin(admin.ModelAdmin):
    prepopulated_fields = {"slug": ["title"]}
```

When set, the given fields will use a bit of JavaScript to populate from the fields assigned. The main use for this functionality is to automatically generate the value for `SlugField` fields from one or more other fields. The generated value is produced by concatenating the values of the source fields, and then by transforming that result into a valid slug (e.g. substituting dashes for spaces and lowercasing ASCII letters).

Prepopulated fields aren’t modified by JavaScript after a value has been saved. It’s usually undesired that slugs change (which would cause an object’s URL to change if the slug is used in it).

`prepopulated_fields` doesn’t accept `DateTimeField`, `ForeignKey`, `OneToOneField`, and `ManyToManyField` fields.


## Set app name

To set the app name in the admin panel, you need to define `verbose_name` in apps.py.
> [!NOTE] Path: `blog\apps.py`
```Python
from django.apps import AppConfig


class BlogConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'blog'
    verbose_name = 'وبلاگ'
```
